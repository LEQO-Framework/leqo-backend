from io import StringIO
from typing import Literal

from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel, Field
from starlette.responses import JSONResponse

from app.model.CompileRequest import Node
from app.model.data_types import LeqoSupportedType


class DiagnosticError(Exception):
    """
    Specified an error that's likely caused by wrong data from a client.
    """

    msg: str
    node: Node | None

    def __init__(self, msg: str, node: Node | None = None) -> None:
        super().__init__(msg)

        self.msg = msg
        self.node = node


type InputCountExpectation = Literal["at-least", "at-most", "equal"]


class InputCountMismatch(DiagnosticError):
    def __init__(
        self, node: Node, actual: int, should_be: InputCountExpectation, expected: int
    ) -> None:
        match should_be:
            case "at-least":
                should_be_str = "at least "
            case "at-most":
                should_be_str = "at most "
            case _:
                should_be_str = ""

        super().__init__(
            f"Node should have {should_be_str}{expected} inputs. Got {actual}.", node
        )


class InputNull(DiagnosticError):
    def __init__(self, node: Node, input_index: int) -> None:
        super().__init__(f"Expected input at index {input_index} but got none.", node)


class InputTypeMismatch(DiagnosticError):
    def __init__(
        self,
        node: Node,
        input_index: int,
        actual: LeqoSupportedType,
        expected: LeqoSupportedType | str,
    ) -> None:
        super().__init__(
            f"Expected type '{expected}' for input {input_index}. Got '{actual}'.",
            node,
        )


class InputSizeMismatch(DiagnosticError):
    def __init__(
        self,
        node: Node,
        input_index: int,
        actual: int,
        expected: int,
    ) -> None:
        super().__init__(
            f"Expected size {expected} for input {input_index}. Got {actual}.",
            node,
        )


def print_exception(
    stream: StringIO, ex: BaseException, is_debug: bool = False
) -> None:
    def print_exception_helper(
        ex: BaseException | None, prefix: str, is_root: bool
    ) -> None:
        if ex is None:
            return

        msg = str(ex) if is_debug else "<Redacted>"
        if isinstance(ex, DiagnosticError):
            msg = ex.msg

        stream.write(f"{prefix}{'' if is_root else '╰ '}{msg}\n")

        if isinstance(ex, BaseExceptionGroup):
            for inner_ex in ex.exceptions:
                print_exception_helper(inner_ex, prefix + "│ ", is_root=True)

        print_exception_helper(
            ex.__cause__, prefix + ("" if is_root else "  "), is_root=False
        )

    print_exception_helper(ex, prefix="", is_root=True)


class ProblemDetails(BaseModel):
    """
    A machine-readable format for specifying errors in HTTP API responses
    based on `RFC7807 <https://tools.ietf.org/html/rfc7807>`_.
    """

    type: str | None = Field(
        default=None,
        description=(
            "A URI reference that identifies the problem type. "
            "Defaults to 'about:blank' if not provided."
        ),
    )
    title: str | None = Field(
        default=None,
        description=(
            "A short, human-readable summary of the problem type. "
            "Intended to remain the same across occurrences of the problem."
        ),
    )
    status: int | None = Field(
        default=None,
        description=(
            "The HTTP status code generated by the origin server for this occurrence of the problem."
        ),
    )
    detail: str | None = Field(
        default=None,
        description="A human-readable explanation specific to this occurrence of the problem.",
    )
    instance: str | None = Field(
        default=None,
        description=(
            "A URI reference that identifies the specific occurrence of the problem. "
            "It may or may not yield further information if dereferenced."
        ),
    )


class LeqoProblemDetails(ProblemDetails):
    """
    :class:`~app.model.exceptions.ProblemDetails` specific for the leqo backend.
    """

    nodeId: str | None = Field(default=None)
    inputIndex: int | None = Field(default=None)

    def to_response(self) -> JSONResponse:
        return JSONResponse(
            jsonable_encoder(self),
            status_code=self.status or 500,
            media_type="application/problem+json",
        )

    @staticmethod
    def from_exception(
        ex: BaseException, is_debug: bool = False
    ) -> "LeqoProblemDetails":
        stream = StringIO()
        print_exception(stream, ex, is_debug)

        if not isinstance(ex, DiagnosticError):
            return LeqoProblemDetails(
                status=500, title="Internal Server Error", detail=stream.getvalue()
            )

        return LeqoProblemDetails(
            status=400,
            title="Bad Request",
            detail=stream.getvalue(),
            nodeId=ex.node.id if ex.node else None,
        )
