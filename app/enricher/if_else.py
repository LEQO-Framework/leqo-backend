from collections.abc import Iterable
from io import UnsupportedOperation
from typing import override
from uuid import uuid4

from openqasm3.ast import (
    AliasStatement,
    Annotation,
    ClassicalDeclaration,
    Identifier,
    IntegerLiteral,
    Pragma,
    Program,
    QubitDeclaration,
    Statement,
)

from app import main
from app.enricher import (
    Constraints,
    EnricherStrategy,
    EnrichmentResult,
    ImplementationMetaData,
)
from app.model.CompileRequest import (
    IfThenElseNode,
    ImplementationNode,
)
from app.model.CompileRequest import Node as FrontendNode
from app.model.data_types import ClassicalType, LeqoSupportedType, QubitType
from app.openqasm3.printer import leqo_dumps
from app.openqasm3.rename import simple_rename
from app.processing import ProcessorIfElse
from app.processing.condition import parse_condition
from app.processing.graph import ProgramGraph, ProgramNode
from app.processing.merge import merge_if_nodes

TARGET_QASM_VERSION = "3.1"  # circular import if imported from converter


def get_pass_node_impl(requested_inputs: dict[int, LeqoSupportedType]) -> Program:
    statements: list[Statement | Pragma] = []

    out_size = 0
    for index, input_type in requested_inputs.items():
        declaration_identifier = Identifier(f"pass_node_declaration_{index}")
        declaration: QubitDeclaration | ClassicalDeclaration
        match input_type:
            case QubitType():
                out_size += input_type.reg_size
                declaration = QubitDeclaration(
                    declaration_identifier,
                    IntegerLiteral(input_type.reg_size),
                )
            case ClassicalType():
                declaration = ClassicalDeclaration(
                    input_type.to_ast(),
                    declaration_identifier,
                    None,
                )
        declaration.annotations = [Annotation("leqo.input", str(index))]
        statements.append(declaration)
        alias = AliasStatement(
            Identifier(f"pass_node_alias_{index}"), declaration_identifier
        )
        alias.annotations = [Annotation("leqo.output", str(index))]
        statements.append(alias)

    return Program(statements, version=TARGET_QASM_VERSION)


class IfElseEnricherStrategy(EnricherStrategy):
    @override
    async def _enrich_impl(
        self,
        node: FrontendNode,
        constraints: Constraints | None,
    ) -> Iterable[EnrichmentResult]:
        if not isinstance(node, IfThenElseNode):
            return []

        if constraints is None:
            msg = "if-else-node requires constraints."
            raise UnsupportedOperation(msg)

        pass_node_impl = leqo_dumps(get_pass_node_impl(constraints.requested_inputs))
        if_id = f"autogenerated_pass_node_{uuid4().hex}"
        if_node = ProgramNode(if_id)
        if_front_node = ImplementationNode(id=if_id, implementation=pass_node_impl)
        endif_id = f"autogenerated_pass_node_{uuid4().hex}"
        endif_node = ProgramNode(endif_id)
        endif_front_node = ImplementationNode(
            id=endif_id, implementation=pass_node_impl
        )

        graphs: list[ProgramGraph] = []
        for nested_block in (node.thenBlock, node.elseBlock):
            nested_block.nodes.extend([if_front_node, endif_front_node])
            for edge in nested_block.edges:
                if edge.source[0] == node.id:
                    edge.source = (if_front_node.id, edge.source[1])
                if edge.target[0] == node.id:
                    edge.target = (endif_front_node.id, edge.target[1])

            opt_width, opt_depth = (
                (None, None)
                if constraints is None
                else (
                    constraints.optimizeWidth,
                    constraints.optimizeDepth,
                )
            )
            processor = ProcessorIfElse(
                main.get_enricher(),
                nested_block.nodes,
                nested_block.edges,
                (if_node, if_front_node),
                (endif_node, endif_front_node),
                opt_width,
                opt_depth,
            )
            graphs.append(await processor.process())
        then_graph, else_graph = tuple(graphs)

        condition = parse_condition(node.condition)
        renames = {}
        for identifier, index in constraints.frontend_name_to_index.items():
            renames[identifier] = then_graph.node_data[if_node].io.inputs[index].name
        condition = simple_rename(condition, renames)

        implementation, out_size = merge_if_nodes(
            if_node,
            endif_node,
            then_graph,
            else_graph,
            condition,
        )
        enriched_node = ImplementationNode(
            id=node.id,
            implementation=leqo_dumps(implementation),
        )
        metadata = ImplementationMetaData(width=out_size, depth=None)
        return [EnrichmentResult(enriched_node=enriched_node, meta_data=metadata)]
